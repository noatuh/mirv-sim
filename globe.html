<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MIRV Simulator - Multiple Independent Reentry Vehicle</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            background: radial-gradient(ellipse at top, #0d0d23, #070712 60%);
            color: white;
            overflow: hidden;
        }
        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 350px;
            max-width: calc(100vw - 40px);
            z-index: 5;
        }
        .ui-right {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 350px;
            max-width: calc(100vw - 40px);
            z-index: 5;
        }
        .panel {
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
            -webkit-backdrop-filter: blur(8px);
            backdrop-filter: blur(8px);
            padding: 16px;
        }
        .panel h2 {
            margin-bottom: 10px;
            font-weight: 700;
            font-size: 18px;
            letter-spacing: 0.3px;
        }
        .row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        .row label { min-width: 120px; font-size: 13px; color: #cfd8ff; }
        .row select, .row input[type="range"] { flex: 1; }
        .row select {
            appearance: none;
            outline: none;
            background: #141428;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 14px;
        }
        .row input[type="number"] {
            background: #141428;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 14px;
            width: 100px;
        }
        .row input[type="range"] {
            background: #141428;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 4px;
            outline: none;
        }
        .row span {
            min-width: 30px;
            font-size: 12px;
            color: #ffd700;
            font-weight: 600;
        }
        .small { font-size: 12px; color: #9bb0ff; margin-top: 6px; line-height: 1.3; }
        .divider { height: 1px; background: linear-gradient(to right, transparent, rgba(255,255,255,0.18), transparent); margin: 12px 0; }
        .counter { margin-top: 8px; font-weight: 600; color: #ffd700; }
        .legend { display: grid; grid-template-columns: 16px 1fr; gap: 8px 10px; align-items: center; margin-top: 10px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; }
        .dot.fireball { background: rgba(255, 160, 0, 0.9); }
        .dot.rad     { background: rgba(0, 255, 255, 0.9); }
        .dot.thermal { background: rgba(255, 64, 64, 0.9); }
        .dot.blastH  { background: rgba(255, 0, 255, 0.7); }
        .dot.blastM  { background: rgba(255, 255, 0, 0.8); }
        .dot.blastL  { background: rgba(0, 255, 0, 0.8); }
        .notice { margin-top: 8px; font-size: 12px; color: #c5d0ff; }
        .notice strong { color: #ffd700; }
    .legend .rowline { display: flex; align-items: center; justify-content: space-between; }
    .legend label { display: inline-flex; align-items: center; gap: 8px; }
    .legend .radius { color: #cfd8ff; font-size: 11px; opacity: 0.9; }
        canvas { display: block; }
    /* Status text hidden by default */
    #statusText { display: none; }
    /* Impacts header */
    .impacts-title { font-size: 14px; margin: 6px 0; }
    /* Lat/Lon tooltip */
    .latlon-tooltip {
        position: fixed;
        z-index: 10;
        background: rgba(20, 20, 40, 0.9);
        border: 1px solid rgba(255,255,255,0.18);
        border-radius: 6px;
        padding: 6px 8px;
        font-size: 12px;
        color: #ffd700;
        pointer-events: none;
        transform: translate(10px, 10px);
        white-space: nowrap;
        display: none;
    }

        /* Buttons */
        .buttons { display: flex; gap: 8px; margin-top: 10px; }
        button {
            background: #293067;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        button:hover { filter: brightness(1.08); }
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* Mode indicator */
        .mode-indicator {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 6px;
            padding: 6px 10px;
            margin-bottom: 10px;
            font-size: 13px;
            font-weight: 600;
            color: #ffd700;
        }
        
        /* Target list */
        .target-list {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(10, 10, 20, 0.6);
            border-radius: 6px;
            padding: 8px;
        }
        .target-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 6px;
            margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 12px;
        }
        .target-item:last-child { margin-bottom: 0; }
        .target-remove {
            background: #cc4444;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="ui">
        <div class="panel">
            <h2>MIRV Simulator</h2>
            <div class="mode-indicator" id="modeIndicator">
                Mode: Set Launch Location
            </div>

            <div class="row">
                <label for="warheadCount">Warheads</label>
                <select id="warheadCount">
                    <option value="3">3 warheads</option>
                    <option value="4">4 warheads</option>
                    <option value="6">6 warheads</option>
                    <option value="8">8 warheads</option>
                    <option value="10">10 warheads</option>
                    <option value="12">12 warheads</option>
                </select>
            </div>

            <div class="row">
                <label for="yieldSelect">Warhead Yield</label>
                <select id="yieldSelect">
                    <option value="0.015">15 kt (Hiroshima)</option>
                    <option value="0.021">21 kt (Nagasaki)</option>
                    <option value="0.1">100 kt</option>
                    <option value="0.3">300 kt (W-76)</option>
                    <option value="0.475">475 kt (W-88)</option>
                    <option value="1">1 Mt</option>
                </select>
            </div>

            <div class="row">
                <label for="timescale">Time Scale</label>
                <input type="range" id="timescale" min="0.1" max="5" step="0.1" value="1">
                <span id="timescaleValue">1x</span>
            </div>

            <div class="row">
                <label for="typeSelect">Detonation</label>
                <select id="typeSelect">
                    <option value="air">Air burst</option>
                    <option value="surface">Surface burst</option>
                </select>
            </div>

            <div class="row">
                <label for="spreadSlider">Target Spread</label>
                <input type="range" id="spreadSlider" min="0" max="500" step="10" />
                <span id="spreadValue"></span>
            </div>

            <div class="row">
                <label for="starsToggle">Show Stars</label>
                <input type="checkbox" id="starsToggle" checked>
            </div>

            <div class="divider"></div>

            <div class="small">
                <strong>Launch Location:</strong> <span id="launchLocation">Not set</span><br/>
                <strong>Target Area:</strong> <span id="targetArea">Not set</span>
            </div>

            <div class="small" id="statusText">
                <!-- Dynamic status updates will appear here -->
            </div>

            <div class="divider"></div>

            <div class="legend" aria-label="Legend">
                <div class="dot fireball"></div>
                <div class="rowline">
                    <label><input type="checkbox" id="fxFireball" checked> Fireball</label>
                    <span id="rFireball" class="radius"></span>
                </div>
                <div class="dot rad"></div>
                <div class="rowline">
                    <label><input type="checkbox" id="fxRadiation" checked> Prompt radiation</label>
                    <span id="rRadiation" class="radius"></span>
                </div>
                <div class="dot thermal"></div>
                <div class="rowline">
                    <label><input type="checkbox" id="fxThermal" checked> Thermal pulse</label>
                    <span id="rThermal" class="radius"></span>
                </div>
                <div class="dot blastH"></div>
                <div class="rowline">
                    <label><input type="checkbox" id="fxBlastH" checked> Heavy blast</label>
                    <span id="rBlastH" class="radius"></span>
                </div>
                <div class="dot blastM"></div>
                <div class="rowline">
                    <label><input type="checkbox" id="fxBlastM" checked> Moderate blast</label>
                    <span id="rBlastM" class="radius"></span>
                </div>
                <div class="dot blastL"></div>
                <div class="rowline">
                    <label><input type="checkbox" id="fxBlastL" checked> Light blast</label>
                    <span id="rBlastL" class="radius"></span>
                </div>
            </div>

            <div class="divider"></div>

            <div class="small">
                <strong>Shift+Click</strong> to set launch location, then target area.<br/>
                Drag to rotate. Scroll to zoom.
            </div>

            <div class="buttons">
                <button id="launchBtn" type="button" disabled>ðŸš€ Launch MIRV</button>
                <button id="stagingBtn" type="button" disabled>ðŸŽ¯ Stage Another</button>
                <button id="clearBtn" type="button">Clear All</button>
            </div>
        </div>
    </div>

    <!-- Right-side coordinates & impacts panel -->
    <div class="ui-right">
        <div class="panel">
            <h2>Coordinates & Impacts</h2>

            <div class="row">
                <label for="launchLat">Launch Lat/Lon</label>
                <input type="number" id="launchLat" placeholder="lat" step="0.00001" min="-90" max="90" />
                <input type="number" id="launchLon" placeholder="lon" step="0.00001" min="-180" max="180" />
            </div>
            <div class="buttons">
                <button id="setLaunchLatLonBtn" type="button">Set Launch</button>
            </div>
            <div class="small">You can also Shift+Click on the globe to set launch.</div>

            <div class="divider"></div>

            <div class="row">
                <label for="latLonGridToggle">Show Lat/Lon Grid</label>
                <input type="checkbox" id="latLonGridToggle" />
            </div>

            <div class="divider"></div>

            <div class="small">
                <strong>Launch lat, lon:</strong> <span id="launchLatLonDisplay">--</span><br/>
                <strong>Target lat, lon:</strong> <span id="targetLatLonDisplay">--</span>
            </div>

            <div class="divider"></div>

            <h3 class="impacts-title">Impacts (lat, lon)</h3>
            <div id="impactsList" class="target-list" aria-label="Impacts"></div>
        </div>
    </div>

    <div id="latLonTooltip" class="latlon-tooltip"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
/* MIRV Simulator - Realistic Multiple Independent Reentry Vehicle Simulation */
class MIRVSimulator {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.earth = null;
        this.clouds = null;

        // Stars
        this.stars = null;
        this.starsEnabled = true;
        
        // MIRV-specific properties
        this.mode = 'launch'; // 'launch', 'target', 'ready'
        this.launchLocation = null;
        this.targetArea = null;
        this.explosions = [];
        this.animatingMIRV = false;
        this.timescale = 1.0;
        this.shiftPressed = false;
        
        // Mission objects - support multiple launches
        this.rocket = null;
        this.warheads = [];
        this.trajectoryLines = [];
        this.rocketTrail = null;
        this.launches = []; // Track all launches
        this.missionCount = 0; // Counter for mission numbering
        this.impactMarkers = []; // Track all impact markers
    this.impacts = []; // Logged impacts with lat/lon
    this.spreadKm = 200; // Default target spread in kilometers
        this.effectsVisible = {
            fireball: true,
            radiation: true,
            thermal: true,
            blastHeavy: true,
            blastModerate: true,
            blastLight: true
        };
        
        this.earthRadius = 1;
        this.animationId = null;
        this.raycaster = null;
        this.mouse = null;
    this.grid = null;
    this.gridEnabled = false;
    this.latLonTooltip = null;

        this.init();
    }

    init() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x00030a, 0.06);

        // Camera
        this.camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 0.8, 2.6);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        // Controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enablePan = false;
        this.controls.minDistance = 1.5;
        this.controls.maxDistance = 8;
        this.controls.autoRotate = false;

        // Raycaster + mouse
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();

        // Lights
        this.setupLights();

        // Globe
        this.setupEarth();
        this.setupAtmosphere();
        this.setupStars();
    this.setupLatLonGrid();

        // UI bindings
        this.bindUI();

        // Events
        window.addEventListener('resize', () => this.onResize());
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Shift') {
                this.shiftPressed = true;
            }
        });
        window.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') {
                this.shiftPressed = false;
            }
        });
        this.renderer.domElement.addEventListener('click', (event) => {
            this.onGlobeClick(event);
        });

        // Start
        this.animate();
    }

    setupLights() {
        const ambient = new THREE.AmbientLight(0x404070, 0.8);
        this.scene.add(ambient);

        const sunLight = new THREE.DirectionalLight(0xfff6e5, 1.2);
        sunLight.position.set(3, 2, 1.5);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        this.scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
        fillLight.position.set(-3, -1, -2);
        this.scene.add(fillLight);
    }

    setupEarth() {
        const loader = new THREE.TextureLoader();

        const earthTexture = loader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_atmos_2048.jpg');
        const normalTexture = loader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_normal_2048.jpg');
        const specTexture   = loader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_specular_2048.jpg');

        const geometry = new THREE.SphereGeometry(this.earthRadius, 96, 96);
        const material = new THREE.MeshPhongMaterial({
            map: earthTexture,
            normalMap: normalTexture,
            specularMap: specTexture,
            specular: new THREE.Color(0x222222),
            shininess: 8
        });

        this.earth = new THREE.Mesh(geometry, material);
        this.earth.receiveShadow = true;
        this.earth.castShadow = true;
        this.scene.add(this.earth);
    }

    setupAtmosphere() {
        const cloudsTexture = new THREE.TextureLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_clouds_1024.png');
        const cloudsGeo = new THREE.SphereGeometry(this.earthRadius * 1.01, 96, 96);
        const cloudsMat = new THREE.MeshLambertMaterial({ map: cloudsTexture, transparent: true, opacity: 0.35 });
        this.clouds = new THREE.Mesh(cloudsGeo, cloudsMat);
        this.scene.add(this.clouds);
    }

    setupStars() {
        // Create procedural star field using points
        const starsGeometry = new THREE.BufferGeometry();
        const starCount = 2000;
        const positions = new Float32Array(starCount * 3);
        const colors = new Float32Array(starCount * 3);
        
        for (let i = 0; i < starCount; i++) {
            // Generate random points on a sphere
            const radius = 50;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;
            
            // Vary star colors (white to slight blue/yellow tint)
            const brightness = 0.5 + Math.random() * 0.5;
            const colorVariation = Math.random();
            
            if (colorVariation < 0.7) {
                // White stars
                colors[i * 3] = brightness;
                colors[i * 3 + 1] = brightness;
                colors[i * 3 + 2] = brightness;
            } else if (colorVariation < 0.85) {
                // Slightly blue stars
                colors[i * 3] = brightness * 0.8;
                colors[i * 3 + 1] = brightness * 0.9;
                colors[i * 3 + 2] = brightness;
            } else {
                // Slightly yellow stars
                colors[i * 3] = brightness;
                colors[i * 3 + 1] = brightness * 0.95;
                colors[i * 3 + 2] = brightness * 0.7;
            }
        }
        
        starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starsGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const starsMaterial = new THREE.PointsMaterial({
            size: 8,
            vertexColors: true,
            transparent: true,
            opacity: 1.0,
            sizeAttenuation: false,
            fog: false  // Disable fog for stars
        });
        
        this.stars = new THREE.Points(starsGeometry, starsMaterial);
        this.stars.visible = this.starsEnabled;
        this.stars.renderOrder = -1; // Render behind everything
        this.scene.add(this.stars);
    }

    setupLatLonGrid() {
        // A subtle grid slightly above the Earth surface to avoid z-fighting
        const R = this.earthRadius * 1.0015;
        const group = new THREE.Group();
        // Use bright lines, draw over scene (no depth test), and ignore fog
        const baseMat = new THREE.LineBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.35,
            depthTest: false,
            depthWrite: false,
            fog: false
        });

        const degStep = 10; // every 10 degrees

        // Meridians (constant longitude): lon goes -180..180, lat sweeps -90..90
        for (let lonDeg = -180; lonDeg <= 180; lonDeg += degStep) {
            const pts = [];
            for (let latDeg = -90; latDeg <= 90; latDeg += 2) {
                pts.push(this.latLonToVector3(latDeg, lonDeg, R));
            }
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            const line = new THREE.Line(geo, baseMat.clone());
            line.renderOrder = 2;
            group.add(line);
        }

        // Parallels (constant latitude): lat goes -80..80 to avoid poles singularity, lon sweeps -180..180
        for (let latDeg = -80; latDeg <= 80; latDeg += degStep) {
            const pts = [];
            for (let lonDeg = -180; lonDeg <= 180; lonDeg += 2) {
                pts.push(this.latLonToVector3(latDeg, lonDeg, R));
            }
            const geo = new THREE.BufferGeometry().setFromPoints(pts);
            const line = new THREE.Line(geo, baseMat.clone());
            line.renderOrder = 2;
            group.add(line);
        }

        group.visible = this.gridEnabled;
        group.renderOrder = 2;
        this.scene.add(group);
        this.grid = group;
    }

    getSurfacePointFromEvent(event) {
        const canvas = this.renderer.domElement;
        let x, y;
        if (typeof event.offsetX === 'number' && typeof event.offsetY === 'number') {
            x = (event.offsetX / canvas.clientWidth) * 2 - 1;
            y = -(event.offsetY / canvas.clientHeight) * 2 + 1;
        } else {
            const rect = canvas.getBoundingClientRect();
            x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        this.mouse.set(x, y);
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const hit = this.raycaster.intersectObject(this.earth);
        if (!hit || !hit.length) return null;
        return hit[0].point.clone().normalize().multiplyScalar(this.earthRadius);
    }

    bindUI() {
        this.warheadCountSelect = document.getElementById('warheadCount');
        this.yieldSelect = document.getElementById('yieldSelect');
        this.typeSelect = document.getElementById('typeSelect');
        this.timescaleSlider = document.getElementById('timescale');
        this.timescaleValue = document.getElementById('timescaleValue');
        this.modeIndicator = document.getElementById('modeIndicator');
        this.launchLocationSpan = document.getElementById('launchLocation');
        this.targetAreaSpan = document.getElementById('targetArea');
        this.statusText = document.getElementById('statusText');
        this.launchBtn = document.getElementById('launchBtn');
        this.stagingBtn = document.getElementById('stagingBtn');
        this.clearBtn = document.getElementById('clearBtn');

        this.starsToggle = document.getElementById('starsToggle');

    // New: launch lat/lon inputs and impacts list
    this.launchLatInput = document.getElementById('launchLat');
    this.launchLonInput = document.getElementById('launchLon');
    this.setLaunchLatLonBtn = document.getElementById('setLaunchLatLonBtn');
    this.impactsList = document.getElementById('impactsList');
    this.launchLatLonDisplay = document.getElementById('launchLatLonDisplay');
    this.targetLatLonDisplay = document.getElementById('targetLatLonDisplay');
    this.spreadSlider = document.getElementById('spreadSlider');
    this.spreadValue = document.getElementById('spreadValue');
    // Legend controls and radius readouts
    this.fxFireball = document.getElementById('fxFireball');
    this.fxRadiation = document.getElementById('fxRadiation');
    this.fxThermal = document.getElementById('fxThermal');
    this.fxBlastH = document.getElementById('fxBlastH');
    this.fxBlastM = document.getElementById('fxBlastM');
    this.fxBlastL = document.getElementById('fxBlastL');
    this.rFireball = document.getElementById('rFireball');
    this.rRadiation = document.getElementById('rRadiation');
    this.rThermal = document.getElementById('rThermal');
    this.rBlastH = document.getElementById('rBlastH');
    this.rBlastM = document.getElementById('rBlastM');
    this.rBlastL = document.getElementById('rBlastL');
    this.latLonGridToggle = document.getElementById('latLonGridToggle');
    this.latLonTooltip = document.getElementById('latLonTooltip');

        this.timescaleSlider.addEventListener('input', (e) => {
            this.timescale = parseFloat(e.target.value);
            this.timescaleValue.textContent = this.timescale + 'x';
        });

        this.launchBtn.addEventListener('click', () => this.launchMIRV());
        this.stagingBtn.addEventListener('click', () => this.stageAnother());
        this.clearBtn.addEventListener('click', () => this.clearAll());

        this.starsToggle.addEventListener('change', (e) => {
            this.starsEnabled = e.target.checked;
            if (this.stars) this.stars.visible = this.starsEnabled;
        });

        // Initialize and bind spread slider
        if (this.spreadSlider) {
            this.spreadSlider.value = String(this.spreadKm);
            if (this.spreadValue) this.spreadValue.textContent = this.spreadKm + ' km';
            this.spreadSlider.addEventListener('input', (e) => {
                const v = parseFloat(e.target.value);
                // Clamp to [0, 500]
                this.spreadKm = Math.max(0, Math.min(500, isNaN(v) ? this.spreadKm : v));
                if (this.spreadValue) this.spreadValue.textContent = this.spreadKm + ' km';
            });
        }

        // Bind legend checkboxes -> toggle effect visibility
        const hook = (el, key) => {
            if (!el) return;
            el.addEventListener('change', () => {
                this.effectsVisible[key] = !!el.checked;
                this.applyEffectsVisibility();
            });
        };
        hook(this.fxFireball, 'fireball');
        hook(this.fxRadiation, 'radiation');
        hook(this.fxThermal, 'thermal');
        hook(this.fxBlastH, 'blastHeavy');
        hook(this.fxBlastM, 'blastModerate');
        hook(this.fxBlastL, 'blastLight');

        // Update radius readouts whenever yield or type changes
        this.yieldSelect.addEventListener('change', () => this.updateRadiusReadouts());
        this.typeSelect.addEventListener('change', () => this.updateRadiusReadouts());
        // Initial fill
        this.updateRadiusReadouts();

        // Lat/Lon grid toggle
        if (this.latLonGridToggle) {
            this.latLonGridToggle.addEventListener('change', (e) => {
                this.gridEnabled = !!e.target.checked;
                if (this.grid) this.grid.visible = this.gridEnabled;
                if (!this.gridEnabled && this.latLonTooltip) this.latLonTooltip.style.display = 'none';
            });
        }

        // Mouse move for lat/lon tooltip (only when grid enabled)
        this.renderer.domElement.addEventListener('mousemove', (event) => {
            if (!this.gridEnabled) return;
            const point = this.getSurfacePointFromEvent(event);
            if (!point) {
                if (this.latLonTooltip) this.latLonTooltip.style.display = 'none';
                return;
            }
            const { lat, lon } = this.vector3ToLatLon(point);
            if (this.latLonTooltip) {
                this.latLonTooltip.textContent = `${lat.toFixed(4)}, ${lon.toFixed(4)}`;
                this.latLonTooltip.style.left = event.clientX + 'px';
                this.latLonTooltip.style.top = event.clientY + 'px';
                this.latLonTooltip.style.display = 'block';
            }
        });
        this.renderer.domElement.addEventListener('mouseleave', () => {
            if (this.latLonTooltip) this.latLonTooltip.style.display = 'none';
        });

        // Set launch by lat/lon
        this.setLaunchLatLonBtn.addEventListener('click', () => {
            const lat = parseFloat(this.launchLatInput.value);
            const lon = parseFloat(this.launchLonInput.value);
            if (Number.isNaN(lat) || Number.isNaN(lon)) {
                this.updateStatus('Enter valid latitude and longitude.');
                return;
            }
            if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                this.updateStatus('Latitude must be [-90,90], longitude [-180,180].');
                return;
            }
            const point = this.latLonToVector3(lat, lon, this.earthRadius);
            this.setLaunchLocation(point);
            this.updateStatus(`Launch set at ${lat.toFixed(5)}, ${lon.toFixed(5)} (deg)`);
        });

        // Copy impact coordinates
        this.impactsList.addEventListener('click', (e) => {
            const btn = e.target.closest('.copy-impact');
            if (!btn) return;
            const idx = parseInt(btn.dataset.index, 10);
            const impact = this.impacts[idx];
            if (!impact) return;
            const text = `${impact.lat.toFixed(5)}, ${impact.lon.toFixed(5)}`;
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    this.updateStatus(`Copied: ${text}`);
                });
            } else {
                const temp = document.createElement('input');
                temp.value = text;
                document.body.appendChild(temp);
                temp.select();
                document.execCommand('copy');
                document.body.removeChild(temp);
                this.updateStatus(`Copied: ${text}`);
            }
        });

        this.updateUI();
    }

    onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Convert a mouse or pointer event into normalized device coordinates
    getPointerNDC(event) {
        const canvas = this.renderer.domElement;
        let x, y;
        if (typeof event.offsetX === 'number' && typeof event.offsetY === 'number') {
            x = (event.offsetX / canvas.clientWidth) * 2 - 1;
            y = -(event.offsetY / canvas.clientHeight) * 2 + 1;
        } else {
            const rect = canvas.getBoundingClientRect();
            x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        this.mouse.set(x, y);
    }

    onGlobeClick(event) {
        if (this.animatingMIRV || !this.shiftPressed) return;
        
        this.getPointerNDC(event);
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObject(this.earth);
        
        if (intersects.length > 0) {
            const point = intersects[0].point.clone().normalize().multiplyScalar(this.earthRadius);
            
            if (this.mode === 'launch') {
                this.setLaunchLocation(point);
            } else if (this.mode === 'target') {
                this.setTargetArea(point);
            }
        }
    }

    setLaunchLocation(point) {
        // Remove existing launch marker
        if (this.launchLocation && this.launchLocation.marker) {
            this.scene.remove(this.launchLocation.marker);
        }

        // Create launch marker (launch pad)
        const launchPadGroup = new THREE.Group();
        
        // Base platform
        const baseGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.003, 16);
        const baseMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 0.0015;
        launchPadGroup.add(base);
        
        // Launch tower
        const towerGeometry = new THREE.BoxGeometry(0.002, 0.025, 0.002);
        const towerMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        tower.position.y = 0.0125;
        launchPadGroup.add(tower);
        
        // Positioning
        launchPadGroup.position.copy(point.clone().normalize().multiplyScalar(this.earthRadius * 1.004));
        launchPadGroup.lookAt(point.clone().normalize().multiplyScalar(this.earthRadius * 2));
        
        this.scene.add(launchPadGroup);
        this.launchLocation = { point: point.clone(), marker: launchPadGroup };
        // Update launch lat/lon display
        const { lat, lon } = this.vector3ToLatLon(point);
        if (this.launchLatLonDisplay) {
            this.launchLatLonDisplay.textContent = `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
        }
        this.mode = 'target';
        this.updateUI();
    }

    setTargetArea(point) {
        // Remove existing target marker
        if (this.targetArea && this.targetArea.marker) {
            this.scene.remove(this.targetArea.marker);
        }

        // Create target area marker (larger circular area)
        const targetGroup = new THREE.Group();
        
        // Target circle
        const circleGeometry = new THREE.RingGeometry(0.02, 0.025, 32);
        const circleMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        circle.rotateX(-Math.PI / 2);
        targetGroup.add(circle);
        
        // Center marker
        const centerGeometry = new THREE.SphereGeometry(0.005, 8, 8);
        const centerMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            emissive: 0x440000
        });
        const center = new THREE.Mesh(centerGeometry, centerMaterial);
        center.position.y = 0.002;
        targetGroup.add(center);
        
        // Positioning
        targetGroup.position.copy(point.clone().normalize().multiplyScalar(this.earthRadius * 1.002));
        targetGroup.lookAt(point.clone().normalize().multiplyScalar(this.earthRadius * 2));
        
        this.scene.add(targetGroup);
        this.targetArea = { point: point.clone(), marker: targetGroup };
        // Update target lat/lon display
        const { lat, lon } = this.vector3ToLatLon(point);
        if (this.targetLatLonDisplay) {
            this.targetLatLonDisplay.textContent = `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
        }
        this.mode = 'ready';
        this.updateUI();
    }

    updateUI() {
        // Update mode indicator
        if (this.mode === 'launch') {
            this.modeIndicator.textContent = 'Mode: Set Launch Location';
            this.statusText.style.display = 'none';
        } else if (this.mode === 'target') {
            this.modeIndicator.textContent = 'Mode: Set Target Area';
            this.statusText.style.display = 'none';
        } else if (this.mode === 'ready') {
            this.modeIndicator.textContent = 'Mode: Ready to Launch';
            this.statusText.style.display = 'none';
        } else if (this.mode === 'launched') {
            this.modeIndicator.textContent = 'Mode: Mission Active';
        }

        // Update location displays
        this.launchLocationSpan.textContent = this.launchLocation ? 'Set' : 'Not set';
        this.targetAreaSpan.textContent = this.targetArea ? 'Set' : 'Not set';

        // Update buttons
        this.launchBtn.disabled = this.mode !== 'ready' || this.animatingMIRV;
        this.stagingBtn.disabled = this.mode !== 'launched' || this.animatingMIRV;
        this.stagingBtn.style.display = this.mode === 'launched' ? 'block' : 'none';
    }

    updateStatus(message) {
        this.statusText.textContent = message;
        this.statusText.style.display = 'block';
    }

    launchMIRV() {
        if (!this.launchLocation || !this.targetArea || this.animatingMIRV) return;

        this.animatingMIRV = true;
        this.missionCount++;
        this.updateUI();
        this.updateStatus(`ðŸš€ Mission #${this.missionCount} launching...`);

        // Store current launch data
        const currentLaunch = {
            id: this.missionCount,
            launchLocation: this.launchLocation.point.clone(),
            targetArea: this.targetArea.point.clone(),
            warheadCount: parseInt(this.warheadCountSelect.value),
            rocket: null,
            warheads: [],
            rocketTrail: null
        };
        
        this.launches.push(currentLaunch);

        // Phase 1: Create and launch the rocket
        this.createRocket(currentLaunch);
        this.startRocketLaunch(currentLaunch);
    }

    stageAnother() {
        // Reset for staging another MIRV
        this.mode = 'launch';
        this.animatingMIRV = false;
        
        // Clear current launch/target markers but keep explosions and trajectories
        if (this.launchLocation && this.launchLocation.marker) {
            this.scene.remove(this.launchLocation.marker);
        }
        if (this.targetArea && this.targetArea.marker) {
            this.scene.remove(this.targetArea.marker);
        }
        
        this.launchLocation = null;
        this.targetArea = null;
        this.rocket = null;
        this.rocketTrail = null;
        
        this.updateUI();
        this.updateStatus('ðŸŽ¯ Ready to stage next MIRV - set launch location');
    }

    createRocket(currentLaunch) {
        const rocketGroup = new THREE.Group();
        
        // Main body
        const bodyGeometry = new THREE.CylinderGeometry(0.003, 0.004, 0.020, 8);
        const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.010;
        rocketGroup.add(body);
        
        // Nose cone
        const noseGeometry = new THREE.ConeGeometry(0.003, 0.008, 8);
        const noseMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
        const nose = new THREE.Mesh(noseGeometry, noseMaterial);
        nose.position.y = 0.024;
        rocketGroup.add(nose);
        
        // Exhaust flame (initially invisible)
        const flameGeometry = new THREE.ConeGeometry(0.006, 0.015, 8);
        const flameMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff6600,
            transparent: true,
            opacity: 0.8
        });
        const flame = new THREE.Mesh(flameGeometry, flameMaterial);
        flame.position.y = -0.0075;
        flame.visible = false;
        rocketGroup.add(flame);
        
        // Position at launch pad
        rocketGroup.position.copy(currentLaunch.launchLocation.clone().normalize().multiplyScalar(this.earthRadius * 1.006));
        rocketGroup.lookAt(currentLaunch.launchLocation.clone().normalize().multiplyScalar(this.earthRadius * 2));
        
        this.scene.add(rocketGroup);
        const rocket = { group: rocketGroup, flame: flame };
        
        currentLaunch.rocket = rocket;
        this.rocket = rocket; // Keep reference for current launch
    }

    startRocketLaunch(currentLaunch) {
        const launchPoint = currentLaunch.launchLocation.clone();
        const targetPoint = currentLaunch.targetArea.clone();
        
        // Calculate trajectory - high arc for intercontinental ballistic missile
        const distance = launchPoint.distanceTo(targetPoint);
        const midPoint = launchPoint.clone().add(targetPoint).multiplyScalar(0.5);
        const apogeeHeight = Math.max(0.4, distance * 0.8); // Very high trajectory
        const apogeePoint = midPoint.clone().normalize().multiplyScalar(this.earthRadius + apogeeHeight);
        
        // Create trajectory curve (quadratic Bezier)
        const trajectory = new THREE.QuadraticBezierCurve3(launchPoint, apogeePoint, targetPoint);
        
        // Create rocket trail for this launch
        const rocketTrail = {
            points: [],
            line: null
        };
        currentLaunch.rocketTrail = rocketTrail;
        this.rocketTrail = rocketTrail; // Keep reference for current launch
        
        // Show exhaust flame
        currentLaunch.rocket.flame.visible = true;
        
        // Phase 1: Rocket ascent (0-60% of trajectory - goes much further before separation)
        const ascentDuration = 20000 / this.timescale; // 20 seconds real time
        const startTime = Date.now();
        
        const animateAscent = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / ascentDuration, 1);
            const trajectoryProgress = progress * 0.6; // Goes to 60% of trajectory before separation
            
            if (progress < 1) {
                const position = trajectory.getPoint(trajectoryProgress);
                currentLaunch.rocket.group.position.copy(position);
                
                // Add point to trail
                rocketTrail.points.push(position.clone());
                
                // Update trail visualization
                this.updateRocketTrail(rocketTrail);
                
                // Orient rocket along trajectory
                const nextPos = trajectory.getPoint(Math.min(trajectoryProgress + 0.01, 1));
                currentLaunch.rocket.group.lookAt(nextPos);
                
                requestAnimationFrame(animateAscent);
            } else {
                // Phase 2: MIRV separation - rocket breaks apart
                this.updateStatus(`ðŸ’¥ Mission #${currentLaunch.id} MIRV separation occurring...`);
                setTimeout(() => this.mirvSeparation(currentLaunch, trajectory, 0.6), 500 / this.timescale);
            }
        };
        
        animateAscent();
    }

    updateRocketTrail(rocketTrail = this.rocketTrail) {
        // Remove old trail line
        if (rocketTrail.line) {
            this.scene.remove(rocketTrail.line);
        }
        
        // Create new trail line
        if (rocketTrail.points.length > 1) {
            const trailGeometry = new THREE.BufferGeometry().setFromPoints(rocketTrail.points);
            const trailMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffdd44,
                transparent: true,
                opacity: 0.8,
                linewidth: 2
            });
            rocketTrail.line = new THREE.Line(trailGeometry, trailMaterial);
            this.scene.add(rocketTrail.line);
        }
    }

    mirvSeparation(currentLaunch, mainTrajectory, separationProgress) {
        // Get the actual separation point from the rocket's current position
        const rocketPosition = currentLaunch.rocket.group.position.clone();
        
        // Create breakup debris from rocket
        this.createRocketBreakup(rocketPosition);
        
        // Remove rocket after brief delay to show breakup
        setTimeout(() => {
            this.scene.remove(currentLaunch.rocket.group);
            currentLaunch.rocket = null;
            this.rocket = null; // Clear current reference
        }, 1000 / this.timescale);
        
        // Generate warhead targets around the target area
        const warheadCount = currentLaunch.warheadCount;
        const targetCenter = currentLaunch.targetArea.clone();
        const warheadTargets = this.generateWarheadTargets(targetCenter, warheadCount);
        
        // Create individual warheads starting from the actual separation point (rocket position)
        currentLaunch.warheads = [];
        
        warheadTargets.forEach((target, index) => {
            setTimeout(() => {
                this.createWarhead(currentLaunch, rocketPosition, target, index);
            }, index * (150 / this.timescale)); // Stagger warhead deployment
        });
        
        this.updateStatus(`ðŸŽ¯ Mission #${currentLaunch.id}: ${warheadCount} warheads deploying...`);
    }

    createRocketBreakup(position) {
        // Create several debris pieces
        for (let i = 0; i < 5; i++) {
            const debrisGeometry = new THREE.BoxGeometry(0.001, 0.003, 0.001);
            const debrisMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x666666,
                transparent: true,
                opacity: 0.8
            });
            const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
            
            // Random position around breakup point
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 0.01,
                (Math.random() - 0.5) * 0.01,
                (Math.random() - 0.5) * 0.01
            );
            debris.position.copy(position.clone().add(offset));
            
            // Random rotation
            debris.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            this.scene.add(debris);
            
            // Animate debris falling
            const fallDuration = 5000 / this.timescale;
            const startTime = Date.now();
            const initialPos = debris.position.clone();
            const fallDirection = position.clone().normalize().multiplyScalar(-0.05);
            
            const animateDebris = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / fallDuration, 1);
                
                if (progress < 1) {
                    const fallOffset = fallDirection.clone().multiplyScalar(progress);
                    debris.position.copy(initialPos.clone().add(fallOffset));
                    debris.rotation.x += 0.1;
                    debris.rotation.y += 0.05;
                    debris.rotation.z += 0.08;
                    requestAnimationFrame(animateDebris);
                } else {
                    this.scene.remove(debris);
                }
            };
            
            setTimeout(animateDebris, i * (200 / this.timescale));
        }
    }

    generateWarheadTargets(centerPoint, count) {
        const targets = [];
        const earthRadiusKm = 6371;
        const kmToGlobe = this.earthRadius / earthRadiusKm;
        const spread = Math.max(0, Math.min(500, this.spreadKm));
        const spreadWorld = spread * kmToGlobe; // spread in world units (on the sphere surface)

        // Build a stable tangent frame at the center point
        const up = centerPoint.clone().normalize();
        // Choose an arbitrary reference that is not colinear with up
        const ref = Math.abs(up.y) < 0.9 ? new THREE.Vector3(0, 1, 0) : new THREE.Vector3(1, 0, 0);
        const tangent1 = new THREE.Vector3().crossVectors(up, ref).normalize();
        const tangent2 = new THREE.Vector3().crossVectors(up, tangent1).normalize();

        for (let i = 0; i < count; i++) {
            // Random direction in tangent plane and random radius within spread
            const theta = Math.random() * Math.PI * 2;
            const r = Math.random() * spreadWorld; // uniform radius (good enough for small areas)
            const offset = tangent1.clone().multiplyScalar(Math.cos(theta) * r)
                .add(tangent2.clone().multiplyScalar(Math.sin(theta) * r));

            const displaced = centerPoint.clone().add(offset);
            const target = displaced.normalize().multiplyScalar(this.earthRadius);
            targets.push(target);
        }

        return targets;
    }

    createWarhead(currentLaunch, startPoint, targetPoint, index) {
        // Create warhead object
        const warheadGeometry = new THREE.SphereGeometry(0.002, 6, 6);
        const warheadMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00,
            emissive: 0xff4400
        });
        const warhead = new THREE.Mesh(warheadGeometry, warheadMaterial);
        warhead.position.copy(startPoint);
        this.scene.add(warhead);
        
        // Create warhead trajectory (follows original rocket trajectory then disperses)
        const trajectoryPoints = this.calculateWarheadTrajectory(currentLaunch, startPoint, targetPoint);
        const trajectory = new THREE.CatmullRomCurve3(trajectoryPoints);
        
        // Create continuous trajectory line that connects to rocket trail
        const fullTrajectoryPoints = [];
        
        // Add rocket trail points first (if they exist)
        if (currentLaunch.rocketTrail && currentLaunch.rocketTrail.points.length > 0) {
            fullTrajectoryPoints.push(...currentLaunch.rocketTrail.points);
        }
        
        // Add warhead trajectory points
        const warheadPoints = trajectory.getPoints(30);
        fullTrajectoryPoints.push(...warheadPoints);
        
        // Create the full trajectory line
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(fullTrajectoryPoints);
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: index === 0 ? 0xffdd44 : 0xff8800, // First warhead keeps rocket trail color, others are orange
            transparent: true,
            opacity: 0.7
        });
        const trajectoryLine = new THREE.Line(lineGeometry, lineMaterial);
        this.scene.add(trajectoryLine);
        
        // If this is the first warhead, hide the original rocket trail since we're replacing it
        if (index === 0 && currentLaunch.rocketTrail && currentLaunch.rocketTrail.line) {
            this.scene.remove(currentLaunch.rocketTrail.line);
            currentLaunch.rocketTrail.line = null;
        }
        
        // Animate warhead descent
        const descentDuration = 8000 / this.timescale; // 8 seconds
        const startTime = Date.now();
        
        const animateDescent = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / descentDuration, 1);
            
            if (progress < 1) {
                const position = trajectory.getPoint(progress);
                warhead.position.copy(position);
                requestAnimationFrame(animateDescent);
            } else {
                // Impact!
                this.scene.remove(warhead);
                // Note: Keep trajectory line visible until clearAll() is called
                this.addExplosion(targetPoint);
                this.addImpactMarker(targetPoint, currentLaunch); // Add persistent impact marker
                this.recordImpact(targetPoint, currentLaunch); // Log and show lat/lon
                
                // Check if all warheads for this launch have impacted
                const completedWarheads = currentLaunch.warheads.filter(w => !w.mesh.parent).length + 1; // +1 for this one
                if (completedWarheads >= currentLaunch.warheadCount) {
                    setTimeout(() => {
                        this.updateStatus(`âœ… Mission #${currentLaunch.id} complete`);
                        this.mode = 'launched'; // Switch to launched mode to show staging button
                        this.animatingMIRV = false;
                        this.updateUI();
                    }, 2000 / this.timescale);
                }
            }
        };
        
        animateDescent();
        const warheadData = { mesh: warhead, trajectory: trajectoryLine };
        currentLaunch.warheads.push(warheadData);
        this.warheads.push(warheadData); // Keep in global array for compatibility
    }

    // Convert a surface point (Vector3) to { lat, lon } in degrees.
    vector3ToLatLon(vec) {
        const r = vec.length();
        const latRad = Math.asin(vec.y / r);
        const lonRad = Math.atan2(vec.z, vec.x);
        return {
            lat: THREE.MathUtils.radToDeg(latRad),
            lon: THREE.MathUtils.radToDeg(lonRad)
        };
    }

    // Convert latitude/longitude in degrees to a position Vector3 on the globe.
    latLonToVector3(latDeg, lonDeg, radius = this.earthRadius) {
        const lat = THREE.MathUtils.degToRad(latDeg);
        const lon = THREE.MathUtils.degToRad(lonDeg);
        const x = radius * Math.cos(lat) * Math.cos(lon);
        const y = radius * Math.sin(lat);
        const z = radius * Math.cos(lat) * Math.sin(lon);
        return new THREE.Vector3(x, y, z);
    }

    // Record impact and update UI list
    recordImpact(surfacePoint, currentLaunch) {
        const { lat, lon } = this.vector3ToLatLon(surfacePoint.clone().normalize().multiplyScalar(this.earthRadius));
        const entry = {
            missionId: currentLaunch.id,
            lat,
            lon,
            timestamp: Date.now()
        };
        this.impacts.push(entry);
        this.appendImpactToList(entry, this.impacts.length - 1);
        this.updateStatus(`Impact at lat ${lat.toFixed(5)}, lon ${lon.toFixed(5)}`);
    }

    appendImpactToList(entry, index) {
        const item = document.createElement('div');
        item.className = 'target-item';
        const latStr = entry.lat.toFixed(5);
        const lonStr = entry.lon.toFixed(5);
        item.innerHTML = `<span>Mission #${entry.missionId}: ${latStr}, ${lonStr}</span><button class="copy-impact" data-index="${index}">Copy</button>`;
        this.impactsList.appendChild(item);
    }

    calculateWarheadTrajectory(currentLaunch, start, target) {
        // Get the original rocket trajectory (launch to target area center)
        const launchPoint = currentLaunch.launchLocation.clone();
        const originalTarget = currentLaunch.targetArea.clone();
        
        // Calculate original trajectory parameters (same as rocket)
        const distance = launchPoint.distanceTo(originalTarget);
        const midPoint = launchPoint.clone().add(originalTarget).multiplyScalar(0.5);
        const apogeeHeight = Math.max(0.4, distance * 0.8);
        const apogeePoint = midPoint.clone().normalize().multiplyScalar(this.earthRadius + apogeeHeight);
        
        // Create the original trajectory curve (same parabola as rocket)
        const originalTrajectory = new THREE.QuadraticBezierCurve3(launchPoint, apogeePoint, originalTarget);
        
        // Find where we are on the original trajectory (separation point)
        const separationProgress = 0.6; // We separate at 60% of the trajectory
        
        // Follow the main trajectory very closely, with minimal dispersal only at the very end
        const points = [];
        const steps = 15;
        
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            
            // Continue along the original trajectory from separation point to target
            const originalProgress = separationProgress + (1 - separationProgress) * t;
            const originalPoint = originalTrajectory.getPoint(originalProgress);
            
            // Only add very slight dispersal in the final 20% of the trajectory
            if (t > 0.8) {
                const dispersalFactor = (t - 0.8) / 0.2; // 0 to 1 in final 20%
                const dispersalAmount = dispersalFactor * dispersalFactor; // Quadratic easing
                
                // Calculate small offset toward individual target (much smaller than before)
                const targetDirection = target.clone().sub(originalTarget).normalize();
                const maxDispersalDistance = 0.008; // Very small dispersal - just enough to reach individual targets
                const dispersalOffset = targetDirection.clone().multiplyScalar(maxDispersalDistance * dispersalAmount);
                
                const point = originalPoint.clone().add(dispersalOffset);
                points.push(point);
            } else {
                // Follow the main trajectory exactly
                points.push(originalPoint);
            }
        }
        
        return points;
    }

    calculateBallisticTrajectory(start, target) {
        const points = [];
        const steps = 8;
        
        // Calculate the distance and height difference
        const startHeight = start.length() - this.earthRadius;
        const targetHeight = 0; // Target is on surface
        
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            
            // Linear interpolation between start and target positions
            const point = start.clone().lerp(target, t);
            
            // Add ballistic arc - starts high, comes down in a realistic curve
            // Use a parabolic descent rather than a sine wave
            const heightProgress = 1 - t; // Goes from 1 to 0
            const additionalHeight = startHeight * heightProgress * heightProgress; // Parabolic descent
            
            // Normalize to sphere surface and add height
            point.normalize().multiplyScalar(this.earthRadius + additionalHeight);
            points.push(point);
        }
        
        return points;
    }

    calculateBlastRadii(yieldMt, detonationType) {
        const isAirBurst = detonationType === 'air';
        const scaleFactor = isAirBurst ? 1.0 : 0.8;
        const yieldKt = yieldMt * 1000;

        // Visualization scaling (km)
        const fireballKm      = Math.pow(yieldKt, 0.40) * 0.05 * scaleFactor;
        const radiationKm     = Math.pow(yieldKt, 0.50) * 0.15 * scaleFactor;
        const thermalKm       = Math.pow(yieldKt, 0.40) * 0.35 * scaleFactor;
        const blastHeavyKm    = Math.pow(yieldKt, 0.33) * 0.20 * scaleFactor;
        const blastModerateKm = Math.pow(yieldKt, 0.33) * 0.50 * scaleFactor;
        const blastLightKm    = Math.pow(yieldKt, 0.33) * 1.20 * scaleFactor;

        const earthRadiusKm = 6371;
        const kmToGlobe = this.earthRadius / earthRadiusKm;

        return {
            fireball:      fireballKm      * kmToGlobe,
            radiation:     radiationKm     * kmToGlobe,
            thermal:       thermalKm       * kmToGlobe,
            blastHeavy:    blastHeavyKm    * kmToGlobe,
            blastModerate: blastModerateKm * kmToGlobe,
            blastLight:    blastLightKm    * kmToGlobe
        };
    }

    updateRadiusReadouts() {
        const yieldMt = parseFloat(this.yieldSelect.value);
        const detonationType = this.typeSelect.value;
        const radii = this.calculateBlastRadii(yieldMt, detonationType);
        const earthRadiusKm = 6371;
        const globeToKm = earthRadiusKm / this.earthRadius;
        const km = (r) => (r * globeToKm).toFixed(1) + ' km';
        if (this.rFireball) this.rFireball.textContent = km(radii.fireball);
        if (this.rRadiation) this.rRadiation.textContent = km(radii.radiation);
        if (this.rThermal) this.rThermal.textContent = km(radii.thermal);
        if (this.rBlastH) this.rBlastH.textContent = km(radii.blastHeavy);
        if (this.rBlastM) this.rBlastM.textContent = km(radii.blastModerate);
        if (this.rBlastL) this.rBlastL.textContent = km(radii.blastLight);
    }

    applyEffectsVisibility() {
        for (const group of this.explosions) {
            if (!group || !group.children) continue;
            group.children.forEach((mesh) => {
                if (!mesh.userData || !mesh.userData.effectKey) return;
                const key = mesh.userData.effectKey;
                if (key in this.effectsVisible) mesh.visible = !!this.effectsVisible[key];
            });
        }
    }

    addExplosion(surfacePoint) {
        const yieldMt = parseFloat(this.yieldSelect.value);
        const detonationType = this.typeSelect.value;
        const radii = this.calculateBlastRadii(yieldMt, detonationType);

        const group = new THREE.Group();
        group.position.copy(surfacePoint.clone().normalize().multiplyScalar(this.earthRadius));

        const up = surfacePoint.clone().normalize();
        const zAxis = new THREE.Vector3(0, 0, 1);
        const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, up);
        group.quaternion.copy(quat);

    const mkRing = (innerR, outerR, color, opacity = 0.6, effectKey = '') => {
            const geom = new THREE.RingGeometry(innerR, outerR, 128, 1);
            const mat = new THREE.MeshBasicMaterial({
                color,
                transparent: true,
                opacity,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.userData.effectKey = effectKey;
            return mesh;
        };

        const rings = [
            mkRing(0.0,              radii.fireball,      0xffa000, 0.85, 'fireball'),
            mkRing(radii.fireball,   radii.radiation,     0x00ffff, 0.50, 'radiation'),
            mkRing(radii.radiation,  radii.thermal,       0xff4040, 0.35, 'thermal'),
            mkRing(radii.thermal,    radii.blastHeavy,    0xff00ff, 0.35, 'blastHeavy'),
            mkRing(radii.blastHeavy, radii.blastModerate, 0xffff00, 0.30, 'blastModerate'),
            mkRing(radii.blastModerate, radii.blastLight, 0x00ff00, 0.25, 'blastLight')
        ];
        rings.forEach(r => group.add(r));

        // Enforce current effect visibility on new rings
        group.children.forEach((mesh) => {
            const key = mesh.userData && mesh.userData.effectKey;
            if (key && (key in this.effectsVisible)) {
                mesh.visible = !!this.effectsVisible[key];
            }
        });

        this.scene.add(group);
        this.explosions.push(group);
    }

    addImpactMarker(surfacePoint, currentLaunch) {
        // Get yield and detonation type from the launch (use current values since we don't store them per launch)
        const yieldMt = parseFloat(this.yieldSelect.value);
        const detonationType = this.typeSelect.value;
        
        // Calculate marker size based on yield and detonation type
        const isAirBurst = detonationType === 'air';
        const yieldKt = yieldMt * 1000;
        
        // Base size calculation - similar to blast radius but smaller for marker
        let baseSize = Math.pow(yieldKt, 0.33) * 0.003; // Base scaling
        if (isAirBurst) {
            baseSize *= 1.2; // Air bursts have slightly larger effective area
        } else {
            baseSize *= 1.0; // Surface bursts are more localized
        }
        
        // Clamp size to reasonable limits
        const markerSize = Math.max(0.002, Math.min(baseSize, 0.015));
        
        // Create impact marker group
        const markerGroup = new THREE.Group();
        
        // Create crater/blast mark - darker center circle
        const craterGeometry = new THREE.CircleGeometry(markerSize, 16);
        const craterMaterial = new THREE.MeshBasicMaterial({
            color: isAirBurst ? 0x2a1a0a : 0x1a1a1a, // Darker for surface burst
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
    const crater = new THREE.Mesh(craterGeometry, craterMaterial);
        markerGroup.add(crater);
        
        // Create scorched earth ring around crater
        const scorchedGeometry = new THREE.RingGeometry(markerSize, markerSize * 1.6, 16);
        const scorchedMaterial = new THREE.MeshBasicMaterial({
            color: isAirBurst ? 0x3a2a1a : 0x2a2a2a,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });
    const scorched = new THREE.Mesh(scorchedGeometry, scorchedMaterial);
        markerGroup.add(scorched);
        
        // Add a subtle glow effect for air bursts
        if (isAirBurst) {
            const glowGeometry = new THREE.RingGeometry(markerSize * 1.6, markerSize * 2.2, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x4a3a2a,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            markerGroup.add(glow);
        }
        
        // Position marker on surface
        markerGroup.position.copy(surfacePoint.clone().normalize().multiplyScalar(this.earthRadius * 1.001));
        
        // Orient marker to surface
        const up = surfacePoint.clone().normalize();
        const zAxis = new THREE.Vector3(0, 0, 1);
        const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, up);
        markerGroup.quaternion.copy(quat);
        
        this.scene.add(markerGroup);
        this.impactMarkers.push({
            marker: markerGroup,
            missionId: currentLaunch.id,
            yield: yieldMt,
            detonationType: detonationType,
            position: surfacePoint.clone()
        });
    }

    clearAll() {
        // Clear explosions
        for (const group of this.explosions) {
            this.scene.remove(group);
            group.traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                    else obj.material.dispose();
                }
            });
        }
        this.explosions = [];

        // Clear impact markers
        for (const markerData of this.impactMarkers) {
            this.scene.remove(markerData.marker);
            markerData.marker.traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                    else obj.material.dispose();
                }
            });
        }
        this.impactMarkers = [];
    // Clear impacts list & data
    this.impacts = [];
    if (this.impactsList) this.impactsList.innerHTML = '';

        // Clear all launches
        for (const launch of this.launches) {
            // Clear rocket
            if (launch.rocket) {
                this.scene.remove(launch.rocket.group);
            }
            
            // Clear rocket trail
            if (launch.rocketTrail && launch.rocketTrail.line) {
                this.scene.remove(launch.rocketTrail.line);
            }
            
            // Clear warheads and their trajectories
            for (const warhead of launch.warheads) {
                this.scene.remove(warhead.mesh);
                this.scene.remove(warhead.trajectory);
            }
        }
        
        // Clear global arrays
        this.launches = [];
        this.warheads = [];
        this.rocket = null;
        this.rocketTrail = null;
        
        // Clear current launch/target markers
        if (this.launchLocation && this.launchLocation.marker) {
            this.scene.remove(this.launchLocation.marker);
        }
        this.launchLocation = null;

        if (this.targetArea && this.targetArea.marker) {
            this.scene.remove(this.targetArea.marker);
        }
    this.targetArea = null;
    if (this.launchLatLonDisplay) this.launchLatLonDisplay.textContent = '--';
    if (this.targetLatLonDisplay) this.targetLatLonDisplay.textContent = '--';

        // Reset state
        this.mode = 'launch';
        this.animatingMIRV = false;
        this.missionCount = 0;
        this.updateUI();
    }

    animate() {
        this.animationId = requestAnimationFrame(() => this.animate());
        if (this.clouds) this.clouds.rotation.y += 0.0004;
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
}

// Global variable to allow UI callbacks
let simulator;
window.addEventListener('DOMContentLoaded', () => {
    simulator = new MIRVSimulator();
});
    </script>
</body>
</html>
