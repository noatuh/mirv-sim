<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MIRV Simulator - Multiple Independent Reentry Vehicle</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            background: radial-gradient(ellipse at top, #0d0d23, #070712 60%);
            color: white;
            overflow: hidden;
        }
        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 350px;
            max-width: calc(100vw - 40px);
            z-index: 5;
        }
        .panel {
            background: rgba(20, 20, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35);
            backdrop-filter: blur(8px);
            padding: 16px;
        }
        .panel h2 {
            margin-bottom: 10px;
            font-weight: 700;
            font-size: 18px;
            letter-spacing: 0.3px;
        }
        .row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; }
        .row label { min-width: 120px; font-size: 13px; color: #cfd8ff; }
        .row select, .row input[type="range"] { flex: 1; }
        .row select {
            appearance: none;
            outline: none;
            background: #141428;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 14px;
        }
        .row input[type="range"] {
            background: #141428;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 4px;
            outline: none;
        }
        .row span {
            min-width: 30px;
            font-size: 12px;
            color: #ffd700;
            font-weight: 600;
        }
        .small { font-size: 12px; color: #9bb0ff; margin-top: 6px; line-height: 1.3; }
        .divider { height: 1px; background: linear-gradient(to right, transparent, rgba(255,255,255,0.18), transparent); margin: 12px 0; }
        .counter { margin-top: 8px; font-weight: 600; color: #ffd700; }
        .legend { display: grid; grid-template-columns: 16px 1fr; gap: 8px 10px; align-items: center; margin-top: 10px; }
        .dot { width: 12px; height: 12px; border-radius: 50%; }
        .dot.fireball { background: rgba(255, 160, 0, 0.9); }
        .dot.rad     { background: rgba(0, 255, 255, 0.9); }
        .dot.thermal { background: rgba(255, 64, 64, 0.9); }
        .dot.blastH  { background: rgba(255, 0, 255, 0.7); }
        .dot.blastM  { background: rgba(255, 255, 0, 0.8); }
        .dot.blastL  { background: rgba(0, 255, 0, 0.8); }
        .notice { margin-top: 8px; font-size: 12px; color: #c5d0ff; }
        .notice strong { color: #ffd700; }
        canvas { display: block; }

        /* Buttons */
        .buttons { display: flex; gap: 8px; margin-top: 10px; }
        button {
            background: #293067;
            color: #fff;
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 14px;
            cursor: pointer;
        }
        button:hover { filter: brightness(1.08); }
        button:active { transform: translateY(1px); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        
        /* Mode indicator */
        .mode-indicator {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            border-radius: 6px;
            padding: 6px 10px;
            margin-bottom: 10px;
            font-size: 13px;
            font-weight: 600;
            color: #ffd700;
        }
        
        /* Target list */
        .target-list {
            max-height: 120px;
            overflow-y: auto;
            background: rgba(10, 10, 20, 0.6);
            border-radius: 6px;
            padding: 8px;
        }
        .target-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 6px;
            margin-bottom: 4px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            font-size: 12px;
        }
        .target-item:last-child { margin-bottom: 0; }
        .target-remove {
            background: #cc4444;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 2px 6px;
            font-size: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="ui">
        <div class="panel">
            <h2>MIRV Simulator</h2>
            <div class="mode-indicator" id="modeIndicator">
                Mode: Set Launch Location
            </div>

            <div class="row">
                <label for="warheadCount">Warheads</label>
                <select id="warheadCount">
                    <option value="3">3 warheads</option>
                    <option value="4">4 warheads</option>
                    <option value="6">6 warheads</option>
                    <option value="8">8 warheads</option>
                    <option value="10">10 warheads</option>
                    <option value="12">12 warheads</option>
                </select>
            </div>

            <div class="row">
                <label for="yieldSelect">Warhead Yield</label>
                <select id="yieldSelect">
                    <option value="0.015">15 kt (Hiroshima)</option>
                    <option value="0.021">21 kt (Nagasaki)</option>
                    <option value="0.1">100 kt</option>
                    <option value="0.3">300 kt (W-76)</option>
                    <option value="0.475">475 kt (W-88)</option>
                    <option value="1">1 Mt</option>
                </select>
            </div>

            <div class="row">
                <label for="timescale">Time Scale</label>
                <input type="range" id="timescale" min="0.1" max="5" step="0.1" value="1">
                <span id="timescaleValue">1x</span>
            </div>

            <div class="row">
                <label for="typeSelect">Detonation</label>
                <select id="typeSelect">
                    <option value="air">Air burst</option>
                    <option value="surface">Surface burst</option>
                </select>
            </div>

            <div class="divider"></div>

            <div class="small">
                <strong>Launch Location:</strong> <span id="launchLocation">Not set</span><br/>
                <strong>Target Area:</strong> <span id="targetArea">Not set</span>
            </div>

            <div class="small" id="statusText" style="display:none;">
                <!-- Dynamic status updates will appear here -->
            </div>

            <div class="divider"></div>

            <div class="legend" aria-label="Legend">
                <div class="dot fireball"></div><div>Fireball</div>
                <div class="dot rad"></div><div>Prompt radiation</div>
                <div class="dot thermal"></div><div>Thermal pulse</div>
                <div class="dot blastH"></div><div>Heavy blast</div>
                <div class="dot blastM"></div><div>Moderate blast</div>
                <div class="dot blastL"></div><div>Light blast</div>
            </div>

            <div class="divider"></div>

            <div class="small">
                <strong>Shift+Click</strong> to set launch location, then target area.<br/>
                Drag to rotate. Scroll to zoom.
            </div>

            <div class="buttons">
                <button id="launchBtn" type="button" disabled>ðŸš€ Launch MIRV</button>
                <button id="stagingBtn" type="button" disabled>ðŸŽ¯ Stage Another</button>
                <button id="clearBtn" type="button">Clear All</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
/* MIRV Simulator - Realistic Multiple Independent Reentry Vehicle Simulation */
class MIRVSimulator {
    constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.controls = null;
        this.earth = null;
        this.clouds = null;
        
        // MIRV-specific properties
        this.mode = 'launch'; // 'launch', 'target', 'ready'
        this.launchLocation = null;
        this.targetArea = null;
        this.explosions = [];
        this.animatingMIRV = false;
        this.timescale = 1.0;
        this.shiftPressed = false;
        
        // Mission objects - support multiple launches
        this.rocket = null;
        this.warheads = [];
        this.trajectoryLines = [];
        this.rocketTrail = null;
        this.launches = []; // Track all launches
        this.missionCount = 0; // Counter for mission numbering
        this.impactMarkers = []; // Track all impact markers
        
        this.earthRadius = 1;
        this.animationId = null;
        this.raycaster = null;
        this.mouse = null;

        this.init();
    }

    init() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x00030a, 0.06);

        // Camera
        this.camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        this.camera.position.set(0, 0.8, 2.6);

        // Renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        this.renderer.shadowMap.enabled = true;
        document.body.appendChild(this.renderer.domElement);

        // Controls
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.controls.enablePan = false;
        this.controls.minDistance = 1.5;
        this.controls.maxDistance = 8;
        this.controls.autoRotate = false;

        // Raycaster + mouse
        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2();

        // Lights
        this.setupLights();

        // Globe
        this.setupEarth();
        this.setupAtmosphere();
        this.setupStars();

        // UI bindings
        this.bindUI();

        // Events
        window.addEventListener('resize', () => this.onResize());
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Shift') {
                this.shiftPressed = true;
            }
        });
        window.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') {
                this.shiftPressed = false;
            }
        });
        this.renderer.domElement.addEventListener('click', (event) => {
            this.onGlobeClick(event);
        });

        // Start
        this.animate();
    }

    setupLights() {
        const ambient = new THREE.AmbientLight(0x404070, 0.8);
        this.scene.add(ambient);

        const sunLight = new THREE.DirectionalLight(0xfff6e5, 1.2);
        sunLight.position.set(3, 2, 1.5);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        this.scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
        fillLight.position.set(-3, -1, -2);
        this.scene.add(fillLight);
    }

    setupEarth() {
        const loader = new THREE.TextureLoader();

        const earthTexture = loader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_atmos_2048.jpg');
        const normalTexture = loader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_normal_2048.jpg');
        const specTexture   = loader.load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_specular_2048.jpg');

        const geometry = new THREE.SphereGeometry(this.earthRadius, 96, 96);
        const material = new THREE.MeshPhongMaterial({
            map: earthTexture,
            normalMap: normalTexture,
            specularMap: specTexture,
            specular: new THREE.Color(0x222222),
            shininess: 8
        });

        this.earth = new THREE.Mesh(geometry, material);
        this.earth.receiveShadow = true;
        this.earth.castShadow = true;
        this.scene.add(this.earth);
    }

    setupAtmosphere() {
        const cloudsTexture = new THREE.TextureLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/planets/earth_clouds_1024.png');
        const cloudsGeo = new THREE.SphereGeometry(this.earthRadius * 1.01, 96, 96);
        const cloudsMat = new THREE.MeshLambertMaterial({ map: cloudsTexture, transparent: true, opacity: 0.35 });
        this.clouds = new THREE.Mesh(cloudsGeo, cloudsMat);
        this.scene.add(this.clouds);
    }

    setupStars() {
        const starGeo = new THREE.SphereGeometry(80, 32, 32);
        const starMat = new THREE.MeshBasicMaterial({
            map: new THREE.TextureLoader().load('https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/textures/galaxy_starfield.png'),
            side: THREE.BackSide,
            depthWrite: false,
            opacity: 0.8,
            transparent: true
        });
        const stars = new THREE.Mesh(starGeo, starMat);
        this.scene.add(stars);
    }

    bindUI() {
        this.warheadCountSelect = document.getElementById('warheadCount');
        this.yieldSelect = document.getElementById('yieldSelect');
        this.typeSelect = document.getElementById('typeSelect');
        this.timescaleSlider = document.getElementById('timescale');
        this.timescaleValue = document.getElementById('timescaleValue');
        this.modeIndicator = document.getElementById('modeIndicator');
        this.launchLocationSpan = document.getElementById('launchLocation');
        this.targetAreaSpan = document.getElementById('targetArea');
        this.statusText = document.getElementById('statusText');
        this.launchBtn = document.getElementById('launchBtn');
        this.stagingBtn = document.getElementById('stagingBtn');
        this.clearBtn = document.getElementById('clearBtn');

        this.timescaleSlider.addEventListener('input', (e) => {
            this.timescale = parseFloat(e.target.value);
            this.timescaleValue.textContent = this.timescale + 'x';
        });

        this.launchBtn.addEventListener('click', () => this.launchMIRV());
        this.stagingBtn.addEventListener('click', () => this.stageAnother());
        this.clearBtn.addEventListener('click', () => this.clearAll());

        this.updateUI();
    }

    onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Convert a mouse or pointer event into normalized device coordinates
    getPointerNDC(event) {
        const canvas = this.renderer.domElement;
        let x, y;
        if (typeof event.offsetX === 'number' && typeof event.offsetY === 'number') {
            x = (event.offsetX / canvas.clientWidth) * 2 - 1;
            y = -(event.offsetY / canvas.clientHeight) * 2 + 1;
        } else {
            const rect = canvas.getBoundingClientRect();
            x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        }
        this.mouse.set(x, y);
    }

    onGlobeClick(event) {
        if (this.animatingMIRV || !this.shiftPressed) return;
        
        this.getPointerNDC(event);
        this.raycaster.setFromCamera(this.mouse, this.camera);
        const intersects = this.raycaster.intersectObject(this.earth);
        
        if (intersects.length > 0) {
            const point = intersects[0].point.clone().normalize().multiplyScalar(this.earthRadius);
            
            if (this.mode === 'launch') {
                this.setLaunchLocation(point);
            } else if (this.mode === 'target') {
                this.setTargetArea(point);
            }
        }
    }

    setLaunchLocation(point) {
        // Remove existing launch marker
        if (this.launchLocation && this.launchLocation.marker) {
            this.scene.remove(this.launchLocation.marker);
        }

        // Create launch marker (launch pad)
        const launchPadGroup = new THREE.Group();
        
        // Base platform
        const baseGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.003, 16);
        const baseMaterial = new THREE.MeshBasicMaterial({ color: 0x444444 });
        const base = new THREE.Mesh(baseGeometry, baseMaterial);
        base.position.y = 0.0015;
        launchPadGroup.add(base);
        
        // Launch tower
        const towerGeometry = new THREE.BoxGeometry(0.002, 0.025, 0.002);
        const towerMaterial = new THREE.MeshBasicMaterial({ color: 0x666666 });
        const tower = new THREE.Mesh(towerGeometry, towerMaterial);
        tower.position.y = 0.0125;
        launchPadGroup.add(tower);
        
        // Positioning
        launchPadGroup.position.copy(point.clone().normalize().multiplyScalar(this.earthRadius * 1.004));
        launchPadGroup.lookAt(point.clone().normalize().multiplyScalar(this.earthRadius * 2));
        
        this.scene.add(launchPadGroup);
        this.launchLocation = { point: point.clone(), marker: launchPadGroup };
        this.mode = 'target';
        this.updateUI();
    }

    setTargetArea(point) {
        // Remove existing target marker
        if (this.targetArea && this.targetArea.marker) {
            this.scene.remove(this.targetArea.marker);
        }

        // Create target area marker (larger circular area)
        const targetGroup = new THREE.Group();
        
        // Target circle
        const circleGeometry = new THREE.RingGeometry(0.02, 0.025, 32);
        const circleMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            transparent: true,
            opacity: 0.7,
            side: THREE.DoubleSide
        });
        const circle = new THREE.Mesh(circleGeometry, circleMaterial);
        circle.rotateX(-Math.PI / 2);
        targetGroup.add(circle);
        
        // Center marker
        const centerGeometry = new THREE.SphereGeometry(0.005, 8, 8);
        const centerMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            emissive: 0x440000
        });
        const center = new THREE.Mesh(centerGeometry, centerMaterial);
        center.position.y = 0.002;
        targetGroup.add(center);
        
        // Positioning
        targetGroup.position.copy(point.clone().normalize().multiplyScalar(this.earthRadius * 1.002));
        targetGroup.lookAt(point.clone().normalize().multiplyScalar(this.earthRadius * 2));
        
        this.scene.add(targetGroup);
        this.targetArea = { point: point.clone(), marker: targetGroup };
        this.mode = 'ready';
        this.updateUI();
    }

    updateUI() {
        // Update mode indicator
        if (this.mode === 'launch') {
            this.modeIndicator.textContent = 'Mode: Set Launch Location';
            this.statusText.style.display = 'none';
        } else if (this.mode === 'target') {
            this.modeIndicator.textContent = 'Mode: Set Target Area';
            this.statusText.style.display = 'none';
        } else if (this.mode === 'ready') {
            this.modeIndicator.textContent = 'Mode: Ready to Launch';
            this.statusText.style.display = 'none';
        } else if (this.mode === 'launched') {
            this.modeIndicator.textContent = 'Mode: Mission Active';
        }

        // Update location displays
        this.launchLocationSpan.textContent = this.launchLocation ? 'Set' : 'Not set';
        this.targetAreaSpan.textContent = this.targetArea ? 'Set' : 'Not set';

        // Update buttons
        this.launchBtn.disabled = this.mode !== 'ready' || this.animatingMIRV;
        this.stagingBtn.disabled = this.mode !== 'launched' || this.animatingMIRV;
        this.stagingBtn.style.display = this.mode === 'launched' ? 'block' : 'none';
    }

    updateStatus(message) {
        this.statusText.textContent = message;
        this.statusText.style.display = 'block';
    }

    launchMIRV() {
        if (!this.launchLocation || !this.targetArea || this.animatingMIRV) return;

        this.animatingMIRV = true;
        this.missionCount++;
        this.updateUI();
        this.updateStatus(`ðŸš€ Mission #${this.missionCount} launching...`);

        // Store current launch data
        const currentLaunch = {
            id: this.missionCount,
            launchLocation: this.launchLocation.point.clone(),
            targetArea: this.targetArea.point.clone(),
            warheadCount: parseInt(this.warheadCountSelect.value),
            rocket: null,
            warheads: [],
            rocketTrail: null
        };
        
        this.launches.push(currentLaunch);

        // Phase 1: Create and launch the rocket
        this.createRocket(currentLaunch);
        this.startRocketLaunch(currentLaunch);
    }

    stageAnother() {
        // Reset for staging another MIRV
        this.mode = 'launch';
        this.animatingMIRV = false;
        
        // Clear current launch/target markers but keep explosions and trajectories
        if (this.launchLocation && this.launchLocation.marker) {
            this.scene.remove(this.launchLocation.marker);
        }
        if (this.targetArea && this.targetArea.marker) {
            this.scene.remove(this.targetArea.marker);
        }
        
        this.launchLocation = null;
        this.targetArea = null;
        this.rocket = null;
        this.rocketTrail = null;
        
        this.updateUI();
        this.updateStatus('ðŸŽ¯ Ready to stage next MIRV - set launch location');
    }

    createRocket(currentLaunch) {
        const rocketGroup = new THREE.Group();
        
        // Main body
        const bodyGeometry = new THREE.CylinderGeometry(0.003, 0.004, 0.020, 8);
        const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0xcccccc });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 0.010;
        rocketGroup.add(body);
        
        // Nose cone
        const noseGeometry = new THREE.ConeGeometry(0.003, 0.008, 8);
        const noseMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
        const nose = new THREE.Mesh(noseGeometry, noseMaterial);
        nose.position.y = 0.024;
        rocketGroup.add(nose);
        
        // Exhaust flame (initially invisible)
        const flameGeometry = new THREE.ConeGeometry(0.006, 0.015, 8);
        const flameMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff6600,
            transparent: true,
            opacity: 0.8
        });
        const flame = new THREE.Mesh(flameGeometry, flameMaterial);
        flame.position.y = -0.0075;
        flame.visible = false;
        rocketGroup.add(flame);
        
        // Position at launch pad
        rocketGroup.position.copy(currentLaunch.launchLocation.clone().normalize().multiplyScalar(this.earthRadius * 1.006));
        rocketGroup.lookAt(currentLaunch.launchLocation.clone().normalize().multiplyScalar(this.earthRadius * 2));
        
        this.scene.add(rocketGroup);
        const rocket = { group: rocketGroup, flame: flame };
        
        currentLaunch.rocket = rocket;
        this.rocket = rocket; // Keep reference for current launch
    }

    startRocketLaunch(currentLaunch) {
        const launchPoint = currentLaunch.launchLocation.clone();
        const targetPoint = currentLaunch.targetArea.clone();
        
        // Calculate trajectory - high arc for intercontinental ballistic missile
        const distance = launchPoint.distanceTo(targetPoint);
        const midPoint = launchPoint.clone().add(targetPoint).multiplyScalar(0.5);
        const apogeeHeight = Math.max(0.4, distance * 0.8); // Very high trajectory
        const apogeePoint = midPoint.clone().normalize().multiplyScalar(this.earthRadius + apogeeHeight);
        
        // Create trajectory curve (quadratic Bezier)
        const trajectory = new THREE.QuadraticBezierCurve3(launchPoint, apogeePoint, targetPoint);
        
        // Create rocket trail for this launch
        const rocketTrail = {
            points: [],
            line: null
        };
        currentLaunch.rocketTrail = rocketTrail;
        this.rocketTrail = rocketTrail; // Keep reference for current launch
        
        // Show exhaust flame
        currentLaunch.rocket.flame.visible = true;
        
        // Phase 1: Rocket ascent (0-60% of trajectory - goes much further before separation)
        const ascentDuration = 20000 / this.timescale; // 20 seconds real time
        const startTime = Date.now();
        
        const animateAscent = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / ascentDuration, 1);
            const trajectoryProgress = progress * 0.6; // Goes to 60% of trajectory before separation
            
            if (progress < 1) {
                const position = trajectory.getPoint(trajectoryProgress);
                currentLaunch.rocket.group.position.copy(position);
                
                // Add point to trail
                rocketTrail.points.push(position.clone());
                
                // Update trail visualization
                this.updateRocketTrail(rocketTrail);
                
                // Orient rocket along trajectory
                const nextPos = trajectory.getPoint(Math.min(trajectoryProgress + 0.01, 1));
                currentLaunch.rocket.group.lookAt(nextPos);
                
                requestAnimationFrame(animateAscent);
            } else {
                // Phase 2: MIRV separation - rocket breaks apart
                this.updateStatus(`ðŸ’¥ Mission #${currentLaunch.id} MIRV separation occurring...`);
                setTimeout(() => this.mirvSeparation(currentLaunch, trajectory, 0.6), 500 / this.timescale);
            }
        };
        
        animateAscent();
    }

    updateRocketTrail(rocketTrail = this.rocketTrail) {
        // Remove old trail line
        if (rocketTrail.line) {
            this.scene.remove(rocketTrail.line);
        }
        
        // Create new trail line
        if (rocketTrail.points.length > 1) {
            const trailGeometry = new THREE.BufferGeometry().setFromPoints(rocketTrail.points);
            const trailMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffdd44,
                transparent: true,
                opacity: 0.8,
                linewidth: 2
            });
            rocketTrail.line = new THREE.Line(trailGeometry, trailMaterial);
            this.scene.add(rocketTrail.line);
        }
    }

    mirvSeparation(currentLaunch, mainTrajectory, separationProgress) {
        // Get the actual separation point from the rocket's current position
        const rocketPosition = currentLaunch.rocket.group.position.clone();
        
        // Create breakup debris from rocket
        this.createRocketBreakup(rocketPosition);
        
        // Remove rocket after brief delay to show breakup
        setTimeout(() => {
            this.scene.remove(currentLaunch.rocket.group);
            currentLaunch.rocket = null;
            this.rocket = null; // Clear current reference
        }, 1000 / this.timescale);
        
        // Generate warhead targets around the target area
        const warheadCount = currentLaunch.warheadCount;
        const targetCenter = currentLaunch.targetArea.clone();
        const warheadTargets = this.generateWarheadTargets(targetCenter, warheadCount);
        
        // Create individual warheads starting from the actual separation point (rocket position)
        currentLaunch.warheads = [];
        
        warheadTargets.forEach((target, index) => {
            setTimeout(() => {
                this.createWarhead(currentLaunch, rocketPosition, target, index);
            }, index * (150 / this.timescale)); // Stagger warhead deployment
        });
        
        this.updateStatus(`ðŸŽ¯ Mission #${currentLaunch.id}: ${warheadCount} warheads deploying...`);
    }

    createRocketBreakup(position) {
        // Create several debris pieces
        for (let i = 0; i < 5; i++) {
            const debrisGeometry = new THREE.BoxGeometry(0.001, 0.003, 0.001);
            const debrisMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x666666,
                transparent: true,
                opacity: 0.8
            });
            const debris = new THREE.Mesh(debrisGeometry, debrisMaterial);
            
            // Random position around breakup point
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 0.01,
                (Math.random() - 0.5) * 0.01,
                (Math.random() - 0.5) * 0.01
            );
            debris.position.copy(position.clone().add(offset));
            
            // Random rotation
            debris.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            
            this.scene.add(debris);
            
            // Animate debris falling
            const fallDuration = 5000 / this.timescale;
            const startTime = Date.now();
            const initialPos = debris.position.clone();
            const fallDirection = position.clone().normalize().multiplyScalar(-0.05);
            
            const animateDebris = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / fallDuration, 1);
                
                if (progress < 1) {
                    const fallOffset = fallDirection.clone().multiplyScalar(progress);
                    debris.position.copy(initialPos.clone().add(fallOffset));
                    debris.rotation.x += 0.1;
                    debris.rotation.y += 0.05;
                    debris.rotation.z += 0.08;
                    requestAnimationFrame(animateDebris);
                } else {
                    this.scene.remove(debris);
                }
            };
            
            setTimeout(animateDebris, i * (200 / this.timescale));
        }
    }

    generateWarheadTargets(centerPoint, count) {
        const targets = [];
        const spreadRadius = 0.03; // Target spread radius
        
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const radius = Math.random() * spreadRadius;
            
            // Calculate offset on sphere surface
            const offset = new THREE.Vector3(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );
            
            const target = centerPoint.clone().add(offset).normalize().multiplyScalar(this.earthRadius);
            targets.push(target);
        }
        
        return targets;
    }

    createWarhead(currentLaunch, startPoint, targetPoint, index) {
        // Create warhead object
        const warheadGeometry = new THREE.SphereGeometry(0.002, 6, 6);
        const warheadMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffaa00,
            emissive: 0xff4400
        });
        const warhead = new THREE.Mesh(warheadGeometry, warheadMaterial);
        warhead.position.copy(startPoint);
        this.scene.add(warhead);
        
        // Create warhead trajectory (follows original rocket trajectory then disperses)
        const trajectoryPoints = this.calculateWarheadTrajectory(currentLaunch, startPoint, targetPoint);
        const trajectory = new THREE.CatmullRomCurve3(trajectoryPoints);
        
        // Create continuous trajectory line that connects to rocket trail
        const fullTrajectoryPoints = [];
        
        // Add rocket trail points first (if they exist)
        if (currentLaunch.rocketTrail && currentLaunch.rocketTrail.points.length > 0) {
            fullTrajectoryPoints.push(...currentLaunch.rocketTrail.points);
        }
        
        // Add warhead trajectory points
        const warheadPoints = trajectory.getPoints(30);
        fullTrajectoryPoints.push(...warheadPoints);
        
        // Create the full trajectory line
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(fullTrajectoryPoints);
        const lineMaterial = new THREE.LineBasicMaterial({ 
            color: index === 0 ? 0xffdd44 : 0xff8800, // First warhead keeps rocket trail color, others are orange
            transparent: true,
            opacity: 0.7
        });
        const trajectoryLine = new THREE.Line(lineGeometry, lineMaterial);
        this.scene.add(trajectoryLine);
        
        // If this is the first warhead, hide the original rocket trail since we're replacing it
        if (index === 0 && currentLaunch.rocketTrail && currentLaunch.rocketTrail.line) {
            this.scene.remove(currentLaunch.rocketTrail.line);
            currentLaunch.rocketTrail.line = null;
        }
        
        // Animate warhead descent
        const descentDuration = 8000 / this.timescale; // 8 seconds
        const startTime = Date.now();
        
        const animateDescent = () => {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / descentDuration, 1);
            
            if (progress < 1) {
                const position = trajectory.getPoint(progress);
                warhead.position.copy(position);
                requestAnimationFrame(animateDescent);
            } else {
                // Impact!
                this.scene.remove(warhead);
                // Note: Keep trajectory line visible until clearAll() is called
                this.addExplosion(targetPoint);
                this.addImpactMarker(targetPoint, currentLaunch); // Add persistent impact marker
                
                // Check if all warheads for this launch have impacted
                const completedWarheads = currentLaunch.warheads.filter(w => !w.mesh.parent).length + 1; // +1 for this one
                if (completedWarheads >= currentLaunch.warheadCount) {
                    setTimeout(() => {
                        this.updateStatus(`âœ… Mission #${currentLaunch.id} complete`);
                        this.mode = 'launched'; // Switch to launched mode to show staging button
                        this.animatingMIRV = false;
                        this.updateUI();
                    }, 2000 / this.timescale);
                }
            }
        };
        
        animateDescent();
        const warheadData = { mesh: warhead, trajectory: trajectoryLine };
        currentLaunch.warheads.push(warheadData);
        this.warheads.push(warheadData); // Keep in global array for compatibility
    }

    calculateWarheadTrajectory(currentLaunch, start, target) {
        // Get the original rocket trajectory (launch to target area center)
        const launchPoint = currentLaunch.launchLocation.clone();
        const originalTarget = currentLaunch.targetArea.clone();
        
        // Calculate original trajectory parameters (same as rocket)
        const distance = launchPoint.distanceTo(originalTarget);
        const midPoint = launchPoint.clone().add(originalTarget).multiplyScalar(0.5);
        const apogeeHeight = Math.max(0.4, distance * 0.8);
        const apogeePoint = midPoint.clone().normalize().multiplyScalar(this.earthRadius + apogeeHeight);
        
        // Create the original trajectory curve (same parabola as rocket)
        const originalTrajectory = new THREE.QuadraticBezierCurve3(launchPoint, apogeePoint, originalTarget);
        
        // Find where we are on the original trajectory (separation point)
        const separationProgress = 0.6; // We separate at 60% of the trajectory
        
        // Follow the main trajectory very closely, with minimal dispersal only at the very end
        const points = [];
        const steps = 15;
        
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            
            // Continue along the original trajectory from separation point to target
            const originalProgress = separationProgress + (1 - separationProgress) * t;
            const originalPoint = originalTrajectory.getPoint(originalProgress);
            
            // Only add very slight dispersal in the final 20% of the trajectory
            if (t > 0.8) {
                const dispersalFactor = (t - 0.8) / 0.2; // 0 to 1 in final 20%
                const dispersalAmount = dispersalFactor * dispersalFactor; // Quadratic easing
                
                // Calculate small offset toward individual target (much smaller than before)
                const targetDirection = target.clone().sub(originalTarget).normalize();
                const maxDispersalDistance = 0.008; // Very small dispersal - just enough to reach individual targets
                const dispersalOffset = targetDirection.clone().multiplyScalar(maxDispersalDistance * dispersalAmount);
                
                const point = originalPoint.clone().add(dispersalOffset);
                points.push(point);
            } else {
                // Follow the main trajectory exactly
                points.push(originalPoint);
            }
        }
        
        return points;
    }

    calculateBallisticTrajectory(start, target) {
        const points = [];
        const steps = 8;
        
        // Calculate the distance and height difference
        const startHeight = start.length() - this.earthRadius;
        const targetHeight = 0; // Target is on surface
        
        for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            
            // Linear interpolation between start and target positions
            const point = start.clone().lerp(target, t);
            
            // Add ballistic arc - starts high, comes down in a realistic curve
            // Use a parabolic descent rather than a sine wave
            const heightProgress = 1 - t; // Goes from 1 to 0
            const additionalHeight = startHeight * heightProgress * heightProgress; // Parabolic descent
            
            // Normalize to sphere surface and add height
            point.normalize().multiplyScalar(this.earthRadius + additionalHeight);
            points.push(point);
        }
        
        return points;
    }

    calculateBlastRadii(yieldMt, detonationType) {
        const isAirBurst = detonationType === 'air';
        const scaleFactor = isAirBurst ? 1.0 : 0.8;
        const yieldKt = yieldMt * 1000;

        // Visualization scaling (km)
        const fireballKm      = Math.pow(yieldKt, 0.40) * 0.05 * scaleFactor;
        const radiationKm     = Math.pow(yieldKt, 0.50) * 0.15 * scaleFactor;
        const thermalKm       = Math.pow(yieldKt, 0.40) * 0.35 * scaleFactor;
        const blastHeavyKm    = Math.pow(yieldKt, 0.33) * 0.20 * scaleFactor;
        const blastModerateKm = Math.pow(yieldKt, 0.33) * 0.50 * scaleFactor;
        const blastLightKm    = Math.pow(yieldKt, 0.33) * 1.20 * scaleFactor;

        const earthRadiusKm = 6371;
        const kmToGlobe = this.earthRadius / earthRadiusKm;

        return {
            fireball:      fireballKm      * kmToGlobe,
            radiation:     radiationKm     * kmToGlobe,
            thermal:       thermalKm       * kmToGlobe,
            blastHeavy:    blastHeavyKm    * kmToGlobe,
            blastModerate: blastModerateKm * kmToGlobe,
            blastLight:    blastLightKm    * kmToGlobe
        };
    }

    addExplosion(surfacePoint) {
        const yieldMt = parseFloat(this.yieldSelect.value);
        const detonationType = this.typeSelect.value;
        const radii = this.calculateBlastRadii(yieldMt, detonationType);

        const group = new THREE.Group();
        group.position.copy(surfacePoint.clone().normalize().multiplyScalar(this.earthRadius));

        const up = surfacePoint.clone().normalize();
        const zAxis = new THREE.Vector3(0, 0, 1);
        const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, up);
        group.quaternion.copy(quat);

        const mkRing = (innerR, outerR, color, opacity = 0.6) => {
            const geom = new THREE.RingGeometry(innerR, outerR, 128, 1);
            const mat = new THREE.MeshBasicMaterial({
                color,
                transparent: true,
                opacity,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.rotateX(Math.PI / 2);
            return mesh;
        };

        const rings = [
            mkRing(0.0,              radii.fireball,      0xffa000, 0.85),
            mkRing(radii.fireball,   radii.radiation,     0x00ffff, 0.50),
            mkRing(radii.radiation,  radii.thermal,       0xff4040, 0.35),
            mkRing(radii.thermal,    radii.blastHeavy,    0xff00ff, 0.35),
            mkRing(radii.blastHeavy, radii.blastModerate, 0xffff00, 0.30),
            mkRing(radii.blastModerate, radii.blastLight, 0x00ff00, 0.25)
        ];
        rings.forEach(r => group.add(r));

        this.scene.add(group);
        this.explosions.push(group);
    }

    addImpactMarker(surfacePoint, currentLaunch) {
        // Get yield and detonation type from the launch (use current values since we don't store them per launch)
        const yieldMt = parseFloat(this.yieldSelect.value);
        const detonationType = this.typeSelect.value;
        
        // Calculate marker size based on yield and detonation type
        const isAirBurst = detonationType === 'air';
        const yieldKt = yieldMt * 1000;
        
        // Base size calculation - similar to blast radius but smaller for marker
        let baseSize = Math.pow(yieldKt, 0.33) * 0.003; // Base scaling
        if (isAirBurst) {
            baseSize *= 1.2; // Air bursts have slightly larger effective area
        } else {
            baseSize *= 1.0; // Surface bursts are more localized
        }
        
        // Clamp size to reasonable limits
        const markerSize = Math.max(0.002, Math.min(baseSize, 0.015));
        
        // Create impact marker group
        const markerGroup = new THREE.Group();
        
        // Create crater/blast mark - darker center circle
        const craterGeometry = new THREE.CircleGeometry(markerSize, 16);
        const craterMaterial = new THREE.MeshBasicMaterial({
            color: isAirBurst ? 0x2a1a0a : 0x1a1a1a, // Darker for surface burst
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        const crater = new THREE.Mesh(craterGeometry, craterMaterial);
        crater.rotateX(-Math.PI / 2);
        markerGroup.add(crater);
        
        // Create scorched earth ring around crater
        const scorchedGeometry = new THREE.RingGeometry(markerSize, markerSize * 1.6, 16);
        const scorchedMaterial = new THREE.MeshBasicMaterial({
            color: isAirBurst ? 0x3a2a1a : 0x2a2a2a,
            transparent: true,
            opacity: 0.6,
            side: THREE.DoubleSide
        });
        const scorched = new THREE.Mesh(scorchedGeometry, scorchedMaterial);
        scorched.rotateX(-Math.PI / 2);
        markerGroup.add(scorched);
        
        // Add a subtle glow effect for air bursts
        if (isAirBurst) {
            const glowGeometry = new THREE.RingGeometry(markerSize * 1.6, markerSize * 2.2, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0x4a3a2a,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.rotateX(-Math.PI / 2);
            markerGroup.add(glow);
        }
        
        // Position marker on surface
        markerGroup.position.copy(surfacePoint.clone().normalize().multiplyScalar(this.earthRadius * 1.001));
        
        // Orient marker to surface
        const up = surfacePoint.clone().normalize();
        const zAxis = new THREE.Vector3(0, 0, 1);
        const quat = new THREE.Quaternion().setFromUnitVectors(zAxis, up);
        markerGroup.quaternion.copy(quat);
        
        this.scene.add(markerGroup);
        this.impactMarkers.push({
            marker: markerGroup,
            missionId: currentLaunch.id,
            yield: yieldMt,
            detonationType: detonationType,
            position: surfacePoint.clone()
        });
    }

    clearAll() {
        // Clear explosions
        for (const group of this.explosions) {
            this.scene.remove(group);
            group.traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                    else obj.material.dispose();
                }
            });
        }
        this.explosions = [];

        // Clear impact markers
        for (const markerData of this.impactMarkers) {
            this.scene.remove(markerData.marker);
            markerData.marker.traverse(obj => {
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) obj.material.forEach(m => m.dispose());
                    else obj.material.dispose();
                }
            });
        }
        this.impactMarkers = [];

        // Clear all launches
        for (const launch of this.launches) {
            // Clear rocket
            if (launch.rocket) {
                this.scene.remove(launch.rocket.group);
            }
            
            // Clear rocket trail
            if (launch.rocketTrail && launch.rocketTrail.line) {
                this.scene.remove(launch.rocketTrail.line);
            }
            
            // Clear warheads and their trajectories
            for (const warhead of launch.warheads) {
                this.scene.remove(warhead.mesh);
                this.scene.remove(warhead.trajectory);
            }
        }
        
        // Clear global arrays
        this.launches = [];
        this.warheads = [];
        this.rocket = null;
        this.rocketTrail = null;
        
        // Clear current launch/target markers
        if (this.launchLocation && this.launchLocation.marker) {
            this.scene.remove(this.launchLocation.marker);
        }
        this.launchLocation = null;

        if (this.targetArea && this.targetArea.marker) {
            this.scene.remove(this.targetArea.marker);
        }
        this.targetArea = null;

        // Reset state
        this.mode = 'launch';
        this.animatingMIRV = false;
        this.missionCount = 0;
        this.updateUI();
    }

    animate() {
        this.animationId = requestAnimationFrame(() => this.animate());
        if (this.clouds) this.clouds.rotation.y += 0.0004;
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
    }
}

// Global variable to allow UI callbacks
let simulator;
window.addEventListener('DOMContentLoaded', () => {
    simulator = new MIRVSimulator();
});
    </script>
</body>
</html>
